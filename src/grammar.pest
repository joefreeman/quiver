// Comments (// ...)
COMMENT = _{ "//" ~ (!("\n" | "\r") ~ ANY)* }

// Whitespace, space, newline
ws = _{ (" " | "\t" | "\n" | "\r\n" | "\r")+ }
sp = _{ (" " | "\t")+ }
nl = _{ "\n" | "\r\n" | "\r" }

// Identifiers
identifier = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHANUMERIC | "_")* ~ "!"? ~ "?"? ~ "'"* }
tuple_name = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")* }

// Function types
function_type = { "#" ~ function_input_type ~ sp ~ "->" ~ sp ~ function_output_type }
function_output_type = {
    "(" ~ ws? ~ type_definition ~ ws? ~ ")" |
    tuple_type |
    primitive_type |
    identifier
}
function_input_type = {
    "(" ~ ws? ~ type_definition ~ ws? ~ ")" |
    tuple_type |
    primitive_type |
    identifier
}

// Tuple types ([Type, Type, ...], Name[Type, ...], Name)
tuple_type = {
    tuple_name ~ "[" ~ ws? ~ field_type_list? ~ ws? ~ "]" |
    "[" ~ ws? ~ field_type_list? ~ ws? ~ "]" |
    tuple_name
}
field_type_list = { field_type ~ (sp? ~ "," ~ ws ~ field_type)* ~ (sp? ~ ",")? }
field_type = { (identifier ~ ":" ~ sp)? ~ type_definition }

// Types
primitive_type = { "int" | "bin" }
base_type = {
    tuple_type |
    primitive_type |
    "(" ~ ws? ~ type_definition ~ ws? ~ ")" |
    identifier
}
type_definition = {
    function_type |
    base_type ~ (ws ~ "|" ~ ws ~ base_type)*
}

// Literals
integer_literal = @{ "-"? ~ ASCII_DIGIT+ }
binary_literal = @{ "'" ~ (ASCII_HEX_DIGIT{2})* ~ "'" }
escape = @{ "\\" ~ ("\"" | "\\" | "n" | "r" | "t") }
string_literal = @{ "\"" ~ (!"\"" ~ (escape | ANY))* ~ "\"" }
literal = { integer_literal | binary_literal | string_literal }

// Patterns
partial_field_list = { identifier ~ (sp? ~ "," ~ ws ~ identifier)* ~ (sp? ~ ",")? }
partial_pattern = { "(" ~ ws? ~ partial_field_list ~ ws? ~ ")" }
pattern_field = { (identifier ~ ":" ~ sp)? ~ pattern }
pattern_field_list = { pattern_field ~ (sp? ~ "," ~ ws ~ pattern_field)* ~ (sp? ~ ",")? }
tuple_pattern = {
    tuple_name ~ "[" ~ ws? ~ pattern_field_list? ~ ws? ~ "]" |
    "[" ~ ws? ~ pattern_field_list? ~ ws? ~ "]" |
    tuple_name
}
star = { "*" }
placeholder = { "_" }
pattern = { partial_pattern | tuple_pattern | literal | star | placeholder | identifier }

// Ripple operator: (~)
ripple = { "~" }

// Value tuple construction (Name[field: value, value, ...], [value, ...], Name)
value_tuple_field = { (identifier ~ ":" ~ sp)? ~ chain }
value_tuple_field_list = { value_tuple_field ~ (sp? ~ "," ~ ws ~ value_tuple_field)* ~ (sp? ~ ",")? }
value_tuple = {
    tuple_name ~ "[" ~ ws? ~ value_tuple_field_list? ~ ws? ~ "]" |
    "[" ~ ws? ~ value_tuple_field_list? ~ ws? ~ "]" |
    tuple_name
}

// Operation tuple construction (supports ripple)
operation_tuple_field = { (identifier ~ ":" ~ sp)? ~ (ripple | chain) }
operation_tuple_field_list = { operation_tuple_field ~ (sp? ~ "," ~ ws ~ operation_tuple_field)* ~ (sp? ~ ",")? }
operation_tuple = {
    tuple_name ~ "[" ~ ws? ~ operation_tuple_field_list? ~ ws? ~ "]" |
    "[" ~ ws? ~ operation_tuple_field_list? ~ ws? ~ "]" |
    tuple_name
}

// Function definitions (#Type { ... }, #[Type, ...] { ... }, #{ ... })
function_definition = { "#" ~ (function_input_type? ~ sp)? ~ block }

// Blocks
branch = { expression ~ (sp ~ "=>" ~ ws ~ expression)? }
block = { "{" ~ ws? ~ ("|" ~ ws)? ~ branch ~ (ws ~ "|" ~ ws ~ branch)* ~ ws? ~ "}" }

// Member access (identifier.foo.0.bar or $.foo.0.bar or bare identifier or $)
member_access = @{ (identifier | "$") ~ ("." ~ (identifier | ASCII_DIGIT+))* }

// Field/positional access (.foo, .0, .1)
field_access = @{ "." ~ identifier }
positional_access = @{ "." ~ ASCII_DIGIT+ }

// Tail-call
tail_call = { "&" ~ identifier? }

// Builtin references (<identifier>)
builtin = { "<" ~ identifier ~ ">" }

// Operators
operator = { equality | not }
equality = { "==" }
not = { "!" }

// Import (%"path")
import = { "%" ~ string_literal }

// Chain
value = {
    literal |
    value_tuple |
    function_definition |
    block |
    member_access |
    import
}
operation = {
    builtin |
    operator |
    operation_tuple |
    block |
    member_access |
    field_access |
    positional_access |
    tail_call
}
chain = { value ~ (ws ~ "~>" ~ sp ~ operation)* }

// Assignment (pattern = chain)
assignment = { pattern ~ sp ~ "=" ~ sp ~ chain }

// Expressions
term = { assignment | chain }
expression = { term ~ (ws? ~ "," ~ ws ~ term)* }

// Type aliases/imports
type_alias = { "type" ~ sp ~ !primitive_type ~ identifier ~ sp ~ "=" ~ sp ~ type_definition }
type_star_pattern = { "*" }
type_partial_pattern = { "(" ~ ws? ~ identifier ~ (ws? ~ "," ~ ws ~ identifier)* ~ ws? ~ ")" }
type_import_pattern = { type_star_pattern | type_partial_pattern }
type_import = { "type" ~ sp ~ type_import_pattern ~ sp ~ "=" ~ sp ~ import }

// Program
statement = { type_import | type_alias | expression }
statements = { statement ~ sp? ~ ((nl | ";") ~ ws? ~ statement)* ~ ws? ~ ";"? }
program = { SOI ~ ws? ~ statements? ~ ws? ~ EOI }
